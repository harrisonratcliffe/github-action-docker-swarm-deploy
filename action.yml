name: 'github-action-docker-swarm-deploy'
description: 'Deploy your Docker Swarm apps in seconds. ðŸš€'
inputs:
  docker_compose_file_path:
    description: 'Set your docker compose file path with the CLI options.'
    default: '-c docker-compose.yml -c docker-compose.prod.yml'
    required: false
  md5_file_path:
    description: 'Set the path to the file you would like to get the MD5 checksum for.'
    default: ''
    required: false
  md5_variable_name:
    description: 'Set the name of the variable to store the MD5 checksum in.'
    default: 'MD5_CHECKSUM'
    required: false
  stack_name:
    description: 'The name of your Docker stack.'
    required: true
  ssh_deploy_private_key:
    description: 'The private key you have authenticated to connect to your servers via SSH.'
    required: true
  ssh_remote_known_hosts:
    description: 'The public key of your SSH servers to validate we are connecting to the right servers.'
    default: ''
    required: false
  ssh_deploy_user:
    description: 'The user that you would like to connect as on the remote servers via SSH.'
    default: 'deploy'
    required: true
  ssh_remote_hostnames:
    description: 'The hostnames or IP addresses of the servers you want to connect to.'
    required: true
  ssh_remote_port:
    description: 'The SSH port of the remote servers you would like to connect to.'
    default: '22'
    required: false
  registry:
    description: 'Comma-separated list of container registries to authenticate with (e.g., "docker.io,ghcr.io").'
    default: 'docker.io' # Default to Docker Hub if not specified
    required: false
  registry-username:
    description: 'The username to use to authenticate with the container registry.'
    required: true
  registry-token:
    description: 'The token or password to use to authenticate with the container registry.'
    required: true
  log_level:
    description: 'The log level to use for the Docker CLI.'
    default: 'debug'
  env_file_base64:
    description: 'The base64 encoded .env file to load into the container.'
    required: false

runs:
  using: 'composite'
  steps:

    - name: Checkout
      uses: actions/checkout@v4

    - name: Set MD5 checksum (if provided)
      if: ${{ inputs.md5_file_path }}
      run: |
        MD5_VALUE=$(md5sum ${{ inputs.md5_file_path }} | awk '{ print $1 }')
        echo "::add-mask::$MD5_VALUE"
        echo "${{ inputs.md5_variable_name }}=$MD5_VALUE" >> $GITHUB_ENV
      shell: bash

    - name: Prepare SSH configuration.
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
      shell: bash

    - name: Add SSH key.
      run: |
        ssh-agent -a $SSH_AUTH_SOCK > /dev/null
        if ! echo "${{ inputs.ssh_deploy_private_key }}" | tr -d '\r' | ssh-add - 2>/dev/null; then
          echo "::error::The provided SSH private key is not in a valid format. Please check your ssh_deploy_private_key input. For more information, see the [github-action-docker-swarm-deploy REA]"
          exit 1
        fi
      env:
        SSH_AUTH_SOCK: /tmp/ssh_agent.sock
      shell: bash

    - name: Verify SSH Connection
      id: ssh-check
      run: |
        echo "::group::Validating SSH Connections"
        set -x  # Enable verbose output

        # Print out the input values for debugging
        echo "Remote Hostnames: ${{ inputs.ssh_remote_hostnames }}"
        echo "Remote Port: ${{ inputs.ssh_remote_port }}"
        echo "Deploy User: ${{ inputs.ssh_deploy_user }}"

        # Split hostnames into an array
        IFS=',' read -ra HOSTS <<< "${{ inputs.ssh_remote_hostnames }}"

        deployment_host=""

        attempt_ssh_connection() {
          local host="$1"
          local ssh_options="$2"

          echo "Attempting SSH connection to $host with options: $ssh_options"

          # Verbose SSH connection attempt with full output
          ssh -vvv $ssh_options -p ${{ inputs.ssh_remote_port }} ${{ inputs.ssh_deploy_user }}@"$host" exit
          connection_result=$?

          echo "SSH Connection Result for $host: $connection_result"
          return $connection_result
        }

        for host in "${HOSTS[@]}"; do
          # Trim whitespace
          host=$(echo "$host" | xargs)

          echo "Processing host: $host"

          # Prepare known hosts file
          temp_known_hosts_file=$(mktemp)

          # Debug: Show known hosts filtering
          echo "Filtering known hosts for $host:"
          grep "^$host " <<< "${{ inputs.ssh_remote_known_hosts }}"

          # Filter known hosts for this specific host
          grep "^$host " <<< "${{ inputs.ssh_remote_known_hosts }}" > "$temp_known_hosts_file"

          # First attempt with strict host key checking
          echo "Attempting connection with strict host key checking"
          if attempt_ssh_connection "$host" "-o BatchMode=yes -o ConnectTimeout=5 -o UserKnownHostsFile=$temp_known_hosts_file -o StrictHostKeyChecking=yes"; then
            echo "SSH connection successful with provided known_hosts to $host"
            deployment_host="$host"
            break
          else
            echo "Strict host key checking failed. Trying without strict checking."

            # Fallback to no strict host checking
            if attempt_ssh_connection "$host" "-o BatchMode=yes -o ConnectTimeout=5 -o StrictHostKeyChecking=no"; then
              echo "::warning::Connection to $host succeeded without strict host key checking."
              deployment_host="$host"
              break
            else
              echo "::warning::SSH CONNECTION FAILED to $host"
            fi
          fi

          # Clean up temporary known hosts file
          rm -f "$temp_known_hosts_file"
        done

        # Check if a deployment host was found
        if [ -z "$deployment_host" ]; then
          echo "::error::SSH CONNECTION FAILED to ALL hosts"
          exit 1
        fi

        # Write output using multiple methods
        echo "Deployment Host: $deployment_host"
        echo "deployment_host=$deployment_host" >> "$GITHUB_OUTPUT"
        echo "deployment_host=$deployment_host"

        echo "::endgroup::"
      shell: bash
      env:
        SSH_AUTH_SOCK: /tmp/ssh_agent.sock

    - name: If provided, use the known_hosts file.
      if: ${{ inputs.ssh_remote_known_hosts }}
      run: |
        echo "${{ inputs.ssh_remote_known_hosts }}" >> ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts
        if [[ "$ACTIONS_STEP_DEBUG" == "true" ]]; then
          echo "::debug::Contents of ~/.ssh/known_hosts:"
          cat ~/.ssh/known_hosts | sed 's/^/::debug::  /'
        fi
      shell: bash

    - name: If no known_hosts file is provided, use ssh-keyscan to get the public key of the remote servers.
      if: ${{ inputs.ssh_remote_known_hosts == '' }}
      run: |
        echo "::warning::Consider setting \"SSH_REMOTE_KNOWN_HOSTS\" as a GitHub Actions secret for improved security.%0A%0A\
        For more information see the harrisonratcliffe/github-action-docker-swarm-deploy README."
        ssh-keyscan -p ${{ inputs.ssh_remote_port }} -H ${{ inputs.ssh_remote_hostnames }} >> ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts
        if [ ! -s ~/.ssh/known_hosts ]; then
          echo "::error::The known_hosts file is empty. This may indicate an issue with the SSH keyscan process."
        else
          if [[ "$ACTIONS_STEP_DEBUG" == "true" ]]; then
            echo "::notice::Debug: Contents of ~/.ssh/known_hosts:"
            cat ~/.ssh/known_hosts | sed 's/^/::notice::Debug:   /'
          fi
        fi
      shell: bash

    - name: Login to registry. (${{ inputs.registry }})
      uses: docker/login-action@v3
      with:
        username: ${{ inputs.registry-username }}
        password: ${{ inputs.registry-token }}
        registry: ${{ inputs.registry }}

    - name: Load .env file and set variables
      if: "${{ inputs.env_file_base64 != '' }}"
      run: |
        # Decode the base64 encoded .env file and save it
        echo "${{ inputs.env_file_base64 }}" | base64 -d > .env
        # Set appropriate permissions for the .env file
        chmod 600 .env

        # Debug: Output the contents of the .env file if debug mode is enabled
        if [[ "$ACTIONS_STEP_DEBUG" == "true" ]]; then
          echo "::debug::Contents of .env file:"
          cat .env | sed 's/^/::debug::  /'
        fi
        
        # First pass: Set all variables without interpolation
        # This ensures all variables are available for the second pass
        while IFS= read -r line || [[ -n "$line" ]]; do
          # Remove leading and trailing whitespace
          line=$(echo "$line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
          
          # Skip empty lines and comments
          if [[ -z "$line" || "$line" == \#* ]]; then
            continue
          fi
          
          # Parse key-value pairs
          if [[ $line =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            
            # Remove surrounding quotes if present
            value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//')
            
            # Export the variable to make it available for the second pass
            export "$key=$value"
          fi
        done < .env
        
        # Second pass: Handle interpolation and set GitHub environment
        while IFS= read -r line || [[ -n "$line" ]]; do
          # Remove leading and trailing whitespace
          line=$(echo "$line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
          
          # Skip empty lines and comments
          if [[ -z "$line" || "$line" == \#* ]]; then
            continue
          fi
          
          # Parse key-value pairs
          if [[ $line =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            
            # Remove surrounding quotes if present
            value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//')
            
            # Handle variable interpolation
            # This allows for variables to reference other variables
            if [[ $value == \$\{*\} ]]; then
              value=$(eval echo "$value")
            fi
            
            # Only process non-empty values
            if [[ -n "$value" ]]; then
              # Mask the value to prevent it from being displayed in logs
              echo "::add-mask::$value"
              # Set the environment variable for GitHub Actions
              echo "$key=$value" >> $GITHUB_ENV
              # Debug: Log which variable is being set
              [[ "$ACTIONS_STEP_DEBUG" == "true" ]] && echo "::debug::Setting $key"
            fi
            
            # Special handling for APP_URL to set SPIN_APP_DOMAIN
            if [[ "$key" == "APP_URL" && -n "$value" && -z "$SPIN_APP_DOMAIN" ]]; then
              # Extract domain from APP_URL
              SPIN_APP_DOMAIN=$(echo "$value" | sed -E 's#^https?://##')
              # Set SPIN_APP_DOMAIN as a GitHub environment variable
              echo "SPIN_APP_DOMAIN=$SPIN_APP_DOMAIN" >> $GITHUB_ENV
              # Mask SPIN_APP_DOMAIN value
              echo "::add-mask::$SPIN_APP_DOMAIN"
              # Debug: Log that SPIN_APP_DOMAIN is being set
              [[ "$ACTIONS_STEP_DEBUG" == "true" ]] && echo "::debug::Setting SPIN_APP_DOMAIN"
            fi
          elif [[ "$ACTIONS_STEP_DEBUG" == "true" ]]; then
            # Debug: Log lines that don't match the expected format
            echo "::debug::Skipping line: $line"
          fi
        done < .env
        
        # Debug: Output all set environment variables if debug mode is enabled
        if [[ "$ACTIONS_STEP_DEBUG" == "true" ]]; then
          echo "::debug::Environment variables set:"
          env | sort | sed 's/^/::debug::  /'
        fi
      shell: bash

    - name: Run Docker Stack deployment via SSH
      run: |
        # Debug output
        echo "SSH Check Step Output:"
        cat $GITHUB_OUTPUT

        # Retrieve the deployment host
        deployment_host=$(grep -oP '(?<=deployment_host=).*' "$GITHUB_OUTPUT")

        if [ -z "$deployment_host" ]; then
          echo "::error::No deployment host found"
          exit 1
        fi

        echo "Deploying to host: $deployment_host"

        docker --log-level ${{ env.ACTIONS_STEP_DEBUG == 'true' && 'debug' || inputs.log_level }} -H ssh://${{ inputs.ssh_deploy_user }}@"$deployment_host":${{ inputs.ssh_remote_port }} \
          stack deploy --detach=false --with-registry-auth \
          ${{ inputs.docker_compose_file_path }} \
          ${{ inputs.stack_name }} \
          --prune
      shell: bash
      env:
        SSH_AUTH_SOCK: /tmp/ssh_agent.sock

branding:
  icon: 'zap'
  color: 'blue'
